なぜ「リクエストに owner を含めなくても」セットされるのか？

Serializer が勝手にやっているわけではなく、
View の perform_create() で明示的に渡しているから

```
def perform_create(self, serializer):
    serializer.save(owner=self.request.user)
```

データの流れ  
① クライアントからのリクエスト  
② Serializer が受け取るデータ  
③ perform_create が介入する　← owner=self.request.user を 強制的に差し込む。validated_data に owner がマージされる  
④ Serializer の create() が呼ばれる　← ここで、owner が「最初からあったかのように」保存される

ポイント💡  
・なりすまし防止のため、クライアントに owner を送らせない  
・「誰が作ったか」は サーバーが責任を持つ

---

ModelSerializer と HyperlinkedModelSerializer の違い

リレーションの表現  
ModelSerializer：外部キーの ID（主キー）  
HyperlinkedModelSerializer：関連オブジェクトの URL（ハイパーリンク）

JSON の見やすさ  
ModelSerializer：シンプルだがリンクはない  
HyperlinkedModelSerializer：リンクでつながるので API が直感的になる

使用場面  
ModelSerializer：内部処理向き、最初の簡単な API  
HyperlinkedModelSerializer：外部クライアントが使う API、RESTful API

フィールド例  
ModelSerializer：owner: 1  
HyperlinkedModelSerializer：owner: "http://127.0.0.1:8000/users/1/"

---

IsAuthenticatedOrReadOnly
パーミッションクラスのひとつで、API のアクセス権限を簡単に管理できるもの

何をするものなのか？
・認証済みユーザー（ログイン済み） → 読み書き OK（GET / POST / PUT / DELETE など）
・未認証ユーザー（ログインしていない） → 読み取りのみ OK（GET だけ）

ログインしていない人は閲覧だけ、書き込みはできないというルールを簡単に設定できる

他のパーミッションクラスとの違い

AllowAny
→ 誰でも読み書き OK

IsAuthenticated
→ 認証済みユーザーだけ読み書き OK

IsAuthenticatedOrReadOnly
→ 未認証は読み取りだけ、認証済みは読み書き OK

IsAdminUser
→ 管理者ユーザーだけ読み書き OK
